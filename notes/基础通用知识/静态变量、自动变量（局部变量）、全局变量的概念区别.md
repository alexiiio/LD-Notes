变量可以分为全局变量、静态变量（包括静态全局变量和静态局部变量）和局部变量（自动变量）。

# 自动变量和静态变量

**自动变量**：使用`auto`修饰的变量，就是局部变量。在计算机编程领域，自动变量（Automatic Variable）指的是局部作用域变量，具体来说即是在控制流进入变量作用域时系统自动为其分配存储空间，并在离开作用域时释放空间的一类变量。默认情况下，在代码块内声明的变量都是自动变量，但亦可用自动变量的关键字`auto`明确标识存储类。

**静态变量**：使用`static`修饰的变量，静态变量（Static Variable）在计算机编程领域指在程序执行前系统就为之静态分配（也即在运行时中不再改变分配情况）存储空间的一类变量。与自动变量对应。

静态变量是相对于自动变量，之所以称为静态变量，是说静态变量不是随着程序作用域的改变而销毁，但是静态变量的访问受到作用域的制约。自动变量是在函数调用栈中分配的，因此随着函数的退出，自动变量不能继续保存原来的值。而静态变量是在静态区中分配的，编译器会对静态变量进行初始化，并且静态变量在整个程序中只有一个，而不像自动变量那样，会根据函数调用的不同具有多个副本。静态变量的值在函数退出后不变。



**区别：**    
- 自动变量（局部变量）存储在栈区，在函数调用时初始化，超出其作用域即释放。根据函数调用不同有多个副本。
- 静态变量存储在全局/静态区，在编译期间初始化，只初始化一次，存在于整个程序运行期间，在程序退出时释放。


关于静态变量只初始化一次的问题：    

```
- (void)viewDidLoad {
    for (int i = 0; i<3; i++) {
        [self testStaticVariable];
    }
}
- (void)testStaticVariable {
    static int a = 3;  // 初始化只执行一次
    a++;
    NSLog(@"%d",a);
}
```
打印：
```
4 5 6
```
如果初始化改成：
```
static int a;  // 相当于static int a = 0; 
a = 3;
```
打印结果就会变成：
```
4 4 4
```

# 全局变量和局部变量

全局变量和局部变量的区别主要在于作用域和生命周期不同。
- 全局变量在整个程序生成期可见，局部变量在自己的作用域可见。
- 全局变量的内存分配是静态的，位于全局/静态区，如果没有赋初值，会被初始化为0。局部变量的内存分配是动态的，位于堆栈中，如果没有初始化，初值视当前内存内的值而定。

# 全局变量、局部变量、静态全局变量、静态局部变量



- 全局变量具有全局作用域。全局变量只需在一个源文件中定义，就可以作用于所有的源文件。当然，其他不包括全局变量定义的源文件需要用extern关键字再次声明这个全局变量。

- 静态全局变量也具有全局作用域，他与全局变量的区别在于如果程序包含多个文件的话，他作用于定义它的文件里，不能作用到其他文件里，即被static关键字修饰过的变量具有文件作用域。这样即使两个不同的源文件都定义了相同的静态全局变量，他们也是不同的变量。

- 局部变量也只有局部作用域，他是自动对象，他在程序运行期间不是一直存在，而是只在函数执行期间存在，函数的一次调用结束后，变量就被撤销，其所占用的内存也被收回。

- 静态局部变量具有局部作用域。它只被初始化一次，自从第一次初始化直到程序结束都一直存在，他和全局变量的区别在于全局变量对所有的函数都是可见的，而静态局部变量只对定义自己的函数体始终可见。
- 全局变量、静态局部变量、静态全局变量都在全局/静态存储区分配空间，而局部变量在栈分配空间。


注意，变量的存储区域也可能有变化，比如：
```
- (void)testLocalVariable {
    Person *person = [[Person alloc]init];
}
```
person是一个局部变量，但他的内存是使用`alloc`动态分配的，实际存储区域在堆区，并不在栈区。




# 使用static修饰变量的作用

1. **延长生命周期**。在修饰局部变量时，变量只初始化一次，初始化之后一直存在，只在程序结束。
2. **限定作用域**。`static`修饰的全局变量，限定只能在本文件内访问，不能在其他文件中访问。（static也可以修饰函数，则这个函数的只能在本文件中调用）


